{"version":3,"sources":["SingleUploader.js"],"names":["define","Emitter","Deferred","elmx","plugins","files","SingleUploader","Plugin","klassName","pluginName","options","selectors","picker","dropzone","pastezone","startUploads","cancelUploads","[object Object]","elm","super","this","_velm","_elm","_initFileHandlers","self","dzSelector","pzSelector","pkSelector","$","dropped","_addFile","pasted","multiple","picked","file","emit","fileMap","Map","jszip","then","zip","defers","forEach","path","zipEntry","d","async","data","dir","set","name","Blob","resolve","push","promise","all","archive","message"],"mappings":";;;;;;;AAAAA,QACC,wBACA,+BACG,oBACA,uBACH,UACA,aACA,cACA,YACC,SACDC,EACAC,EACAC,EACAC,EACAC,GAoJA,OAAOA,EAAMC,6BA5IgBF,EAAQG,OACpCC,gBACI,MAAO,iBAGRC,iBACG,MAAO,sBAGbC,cACM,OACKC,WACEC,OAAW,eACXC,SAAW,iBACXC,UAAW,kBAEXC,aAAc,iBACdC,cAAe,oBAU3BC,YAAaC,EAAKR,GACjBS,MAAMD,EAAIR,GAENU,KAAKC,MAAQlB,EAAKiB,KAAKE,MAE3BF,KAAKG,oBAILN,oBACI,IAAIO,EAAOJ,KAEPT,EAAYS,KAAKV,QAAQC,UAC5Bc,EAAad,EAAUE,SACvBa,EAAaf,EAAUG,UACvBa,EAAahB,EAAUC,OAEpBa,GACTL,KAAKC,MAAMO,EAAEH,GAAYZ,UACZgB,QAAU,SAAUxB,GAChBmB,EAAKM,SAASzB,EAAM,OAM5BqB,GACAN,KAAKC,MAAMO,EAAEF,GAAYZ,WACrBiB,OAAS,SAAU1B,GACfmB,EAAKM,SAASzB,EAAM,OAK5BsB,GACAP,KAAKC,MAAMO,EAAED,GAAYf,QACrBoB,UAAU,EACVC,OAAS,SAAU5B,GACfmB,EAAKM,SAASzB,EAAM,OAMnCY,SAASiB,GACNd,KAAKe,KAAK,QAASD,GAOxBjB,WASAA,SAAUiB,GACR,MACME,EAAU,IAAIC,IAkBpBC,MAAMJ,GAAMK,KAAMC,IACX,IAAIC,KAETD,EAAIE,QAAQ,CAACC,EAAKC,KAIf,IAAIC,EAAI,IAAI3C,EACV0C,EAASE,MAAM,eAAeP,KAAK,SAASQ,GACrCH,EAASI,KACZZ,EAAQa,IAAIL,EAASM,KAAK,IAAIC,MAAMJ,KAErCF,EAAEO,YAELX,EAAOY,KAAKR,EAAES,WAElBpD,EAASqD,IAAId,GAAQF,KAAM,KAC1BnB,KAAKe,KAAK,QAAS9B,MAAO+B,EAASoB,QAAStB,QAUlDjB,MAAOwC,GACLrC,KAAKe,KAAK,QAASsB,QAASA","file":"../SingleUploader.js","sourcesContent":["define([\r\n\t\"skylark-langx-emitter\",\r\n\t\"skylark-langx-async/Deferred\",\r\n    \"skylark-domx-velm\",\r\n    \"skylark-domx-plugins\",\r\n\t\"./files\",\r\n\t\"./dropzone\",\r\n\t\"./pastezone\",\r\n\t\"./picker\"\r\n],function(\r\n\tEmitter, \r\n\tDeferred, \r\n\telmx,\r\n\tplugins,\r\n\tfiles\r\n) {\r\n\t//import ZipLoader from 'zip-loader';\r\n\r\n\t/**\r\n\t * Watches an element for file drops, parses to create a filemap hierarchy,\r\n\t * and emits the result.\r\n\t */\r\n\tclass SingleUploader extends plugins.Plugin {\r\n\t\tget klassName() {\r\n\t    \treturn \"SingleUploader\";\r\n    \t} \r\n\r\n    \tget pluginName(){\r\n      \t\treturn \"lark.singleuploader\";\r\n    \t} \r\n\r\n\t\tget options () {\r\n      \t\treturn {\r\n\t            selectors : {\r\n\t              picker   : \".file-picker\",\r\n\t              dropzone : \".file-dropzone\",\r\n\t              pastezone: \".file-pastezone\",\r\n\r\n\t              startUploads: '.start-uploads',\r\n\t              cancelUploads: '.cancel-uploads',\r\n\t            }\r\n\t     \t}\r\n\t\t}\r\n\r\n\r\n\t  /**\r\n\t   * @param  {Element} elm\r\n\t   * @param  [options] \r\n\t   */\r\n\t  constructor (elm, options) {\r\n\t  \tsuper(elm,options);\r\n\r\n        this._velm = elmx(this._elm);\r\n\r\n\t  \tthis._initFileHandlers();\r\n\r\n\t}\r\n\r\n    _initFileHandlers () {\r\n        var self = this;\r\n\r\n        var selectors = this.options.selectors,\r\n        \tdzSelector = selectors.dropzone,\r\n        \tpzSelector = selectors.pastezone,\r\n        \tpkSelector = selectors.picker;\r\n\r\n        if (dzSelector) {\r\n\t\t\tthis._velm.$(dzSelector).dropzone({\r\n                dropped : function (files) {\r\n                    self._addFile(files[0]);\r\n                }\r\n\t\t\t});\r\n        }\r\n\r\n\r\n        if (pzSelector) {\r\n            this._velm.$(pzSelector).pastezone({\r\n                pasted : function (files) {\r\n                    self._addFile(files[0]);\r\n                }\r\n            });                \r\n        }\r\n\r\n        if (pkSelector) {\r\n            this._velm.$(pkSelector).picker({\r\n                multiple: true,\r\n                picked : function (files) {\r\n                    self._addFile(files[0]);\r\n                }\r\n            });                \r\n        }\r\n    }\r\n\r\n     _addFile(file) {\r\n        this.emit('added', file);\t  \r\n     }\r\n\r\n\r\n\t  /**\r\n\t   * Destroys the instance.\r\n\t   */\r\n\t  destroy () {\r\n\t  }\r\n\r\n\r\n\t  /**\r\n\t   * Inflates a File in .ZIP format, creates the fileMap tree, and emits the\r\n\t   * result.\r\n\t   * @param  {File} file\r\n\t   */\r\n\t  _loadZip (file) {\r\n\t    const pending = [];\r\n\t    const fileMap = new Map();\r\n\r\n\t    const traverse = (node) => {\r\n\t      if (node.directory) {\r\n\t        node.children.forEach(traverse);\r\n\t      } else if (node.name[0] !== '.') {\r\n\t        pending.push(new Promise((resolve) => {\r\n\t          node.getData(new zip.BlobWriter(), (blob) => {\r\n\t            blob.name = node.name;\r\n\t            fileMap.set(node.getFullname(), blob);\r\n\t            resolve();\r\n\t          });\r\n\t        }));\r\n\t      }\r\n\t    };\r\n\r\n\t    var self = this;\r\n\r\n\t    jszip(file).then((zip) => {\r\n            var defers = [];\r\n\r\n\t     \tzip.forEach((path,zipEntry) => {\r\n\t        \t//if (path.match(/\\/$/)) return;\r\n\t        \t//const fileName = path.replace(/^.*[\\\\\\/]/, '');\r\n\t        \t//fileMap.set(path, new File([archive.files[path].buffer], fileName));\r\n\t        \tvar d = new Deferred();\r\n\t          \tzipEntry.async(\"arraybuffer\").then(function(data){\r\n\t            \tif (!zipEntry.dir) {\r\n\t             \t\tfileMap.set(zipEntry.name,new Blob([data]));\r\n\t            \t} \r\n             \t\td.resolve();\r\n\t          \t});\r\n\t          \tdefers.push(d.promise);\r\n\t      \t});\r\n\t      \tDeferred.all(defers).then( () =>{\r\n\t      \t\tthis.emit('drop', {files: fileMap, archive: file});\r\n\t      \t});\r\n\t    });\r\n\t  }\r\n\r\n\r\n\t  /**\r\n\t   * @param {string} message\r\n\t   * @throws\r\n\t   */\r\n\t  _fail (message) {\r\n\t    this.emit('fail', {message: message});\r\n\t  }\r\n\t}\r\n\r\n\treturn files.SingleUploader = SingleUploader;\r\n\r\n});\r\n\r\n "]}